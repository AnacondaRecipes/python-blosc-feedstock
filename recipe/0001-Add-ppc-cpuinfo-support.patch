--- work_failed_provide/cpuinfo.py.orig	2017-03-10 02:44:09.000000000 -0500
+++ work_failed_provide/cpuinfo.py	2018-07-08 10:46:34.630717545 -0400
@@ -1,9 +1,9 @@
 #!/usr/bin/env python
 # -*- coding: UTF-8 -*-
 
-# Copyright (c) 2014-2016, Matthew Brennan Jones <matthew.brennan.jones@gmail.com>
-# Py-cpuinfo is a Python module to show the cpuinfo of a processor
-# It uses a MIT style license
+# Copyright (c) 2014-2018, Matthew Brennan Jones <matthew.brennan.jones@gmail.com>
+# Py-cpuinfo gets CPU info with pure Python 2 & 3
+# It uses the MIT License
 # It is hosted at: https://github.com/workhorsy/py-cpuinfo
 #
 # Permission is hereby granted, free of charge, to any person obtaining
@@ -25,8 +25,10 @@
 # TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
+CPUINFO_VERSION = (4, 0, 0)
 
 import os, sys
+import glob
 import re
 import time
 import platform
@@ -46,12 +48,45 @@
 
 PY2 = sys.version_info[0] == 2
 
+# Load hacks for Windows
+if platform.system().lower() == 'windows':
+	# Monkey patch multiprocessing's Popen to fork properly on Windows Pyinstaller
+	# https://github.com/pyinstaller/pyinstaller/wiki/Recipe-Multiprocessing
+	try:
+		import multiprocessing.popen_spawn_win32 as forking
+	except ImportError as err:
+		try:
+			import multiprocessing.popen_fork as forking
+		except ImportError as err:
+			import multiprocessing.forking as forking
+
+	class _Popen(forking.Popen):
+		def __init__(self, *args, **kw):
+			if hasattr(sys, 'frozen'):
+				# We have to set original _MEIPASS2 value from sys._MEIPASS
+				# to get --onefile mode working.
+				os.putenv('_MEIPASS2', sys._MEIPASS)
+			try:
+				super(_Popen, self).__init__(*args, **kw)
+			finally:
+				if hasattr(sys, 'frozen'):
+					# On some platforms (e.g. AIX) 'os.unsetenv()' is not
+					# available. In those cases we cannot delete the variable
+					# but only set it to the empty string. The bootloader
+					# can handle this case.
+					if hasattr(os, 'unsetenv'):
+						os.unsetenv('_MEIPASS2')
+					else:
+						os.putenv('_MEIPASS2', '')
+
+	forking.Popen = _Popen
 
 class DataSource(object):
 	bits = platform.architecture()[0]
 	cpu_count = multiprocessing.cpu_count()
 	is_windows = platform.system().lower() == 'windows'
 	raw_arch_string = platform.machine()
+	can_cpuid = True
 
 	@staticmethod
 	def has_proc_cpuinfo():
@@ -62,6 +97,11 @@
 		return len(program_paths('dmesg')) > 0
 
 	@staticmethod
+	def has_var_run_dmesg_boot():
+		uname = platform.system().strip().strip('"').strip("'").strip().lower()
+		return 'linux' in uname and os.path.exists('/var/run/dmesg.boot')
+
+	@staticmethod
 	def has_cpufreq_info():
 		return len(program_paths('cpufreq-info')) > 0
 
@@ -90,6 +130,15 @@
 		return len(program_paths('lscpu')) > 0
 
 	@staticmethod
+	def has_ibm_pa_features():
+		return len(program_paths('lsprop')) > 0
+
+	@staticmethod
+	def has_wmic():
+		returncode, output = run_and_get_stdout(['wmic', 'os', 'get', 'Version'])
+		return returncode == 0 and len(output) > 0
+
+	@staticmethod
 	def cat_proc_cpuinfo():
 		return run_and_get_stdout(['cat', '/proc/cpuinfo'])
 
@@ -110,6 +159,10 @@
 		return run_and_get_stdout(['dmesg', '-a'])
 
 	@staticmethod
+	def cat_var_run_dmesg_boot():
+		return run_and_get_stdout(['cat', '/var/run/dmesg.boot'])
+
+	@staticmethod
 	def sysctl_machdep_cpu_hw_cpufrequency():
 		return run_and_get_stdout(['sysctl', 'machdep.cpu', 'hw.cpufrequency'])
 
@@ -130,6 +183,16 @@
 		return run_and_get_stdout(['lscpu'])
 
 	@staticmethod
+	def ibm_pa_features():
+		ibm_features = glob.glob('/proc/device-tree/cpus/*/ibm,pa-features')
+		if ibm_features:
+			return run_and_get_stdout(['lsprop', ibm_features[0]])
+
+	@staticmethod
+	def wmic_cpu():
+		return run_and_get_stdout(['wmic', 'cpu', 'get', 'Name,CurrentClockSpeed,L2CacheSize,L3CacheSize,Description,Caption,Manufacturer', '/format:list'])
+
+	@staticmethod
 	def winreg_processor_brand():
 		key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"Hardware\Description\System\CentralProcessor\0")
 		processor_brand = winreg.QueryValueEx(key, "ProcessorNameString")[0]
@@ -173,19 +236,22 @@
 	return d
 
 def b64_to_obj(thing):
-	a = base64.b64decode(thing)
-	b = pickle.loads(a)
-	return b
+	try:
+		a = base64.b64decode(thing)
+		b = pickle.loads(a)
+		return b
+	except:
+		return {}
 
 def run_and_get_stdout(command, pipe_command=None):
 	if not pipe_command:
-		p1 = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+		p1 = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
 		output = p1.communicate()[0]
 		if not PY2:
 			output = output.decode(encoding='UTF-8')
 		return p1.returncode, output
 	else:
-		p1 = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+		p1 = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
 		p2 = subprocess.Popen(pipe_command, stdin=p1.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
 		p1.stdout.close()
 		output = p2.communicate()[0]
@@ -263,46 +329,6 @@
 
 	return (scale, hz_brand)
 
-def _get_hz_string_from_beagle_bone():
-	scale, hz_brand = 1, '0.0'
-
-	if not DataSource.has_cpufreq_info():
-		return scale, hz_brand
-
-	returncode, output = DataSource.cpufreq_info()
-	if returncode != 0:
-		return (scale, hz_brand)
-
-	hz_brand = output.split('current CPU frequency is')[1].split('.')[0].lower()
-
-	if hz_brand.endswith('mhz'):
-		scale = 6
-	elif hz_brand.endswith('ghz'):
-		scale = 9
-	hz_brand = hz_brand.rstrip('mhz').rstrip('ghz').strip()
-	hz_brand = to_hz_string(hz_brand)
-
-	return (scale, hz_brand)
-
-def _get_hz_string_from_lscpu():
-	scale, hz_brand = 1, '0.0'
-
-	if not DataSource.has_lscpu():
-		return scale, hz_brand
-
-	returncode, output = DataSource.lscpu()
-	if returncode != 0:
-		return (scale, hz_brand)
-
-	new_hz = _get_field(False, output, None, None, 'CPU max MHz', 'CPU MHz')
-	if new_hz == None:
-		return (scale, hz_brand)
-
-	new_hz = to_hz_string(new_hz)
-	scale = 6
-
-	return (scale, new_hz)
-
 def to_friendly_hz(ticks, scale):
 	# Get the raw Hz as a string
 	left, right = to_raw_hz(ticks, scale)
@@ -364,6 +390,161 @@
 
 	return ticks
 
+def to_friendly_bytes(input):
+	if not input:
+		return input
+	input = "{0}".format(input)
+
+	formats = {
+		r"^[0-9]+B$" : 'B',
+		r"^[0-9]+K$" : 'KB',
+		r"^[0-9]+M$" : 'MB',
+		r"^[0-9]+G$" : 'GB'
+	}
+
+	for pattern, friendly_size in formats.items():
+		if re.match(pattern, input):
+			return "{0} {1}".format(input[ : -1].strip(), friendly_size)
+
+	return input
+
+def _parse_cpu_string(cpu_string):
+	# Get location of fields at end of string
+	fields_index = cpu_string.find('(', cpu_string.find('@'))
+	#print(fields_index)
+
+	# Processor Brand
+	processor_brand = cpu_string
+	if fields_index != -1:
+		processor_brand = cpu_string[0 : fields_index].strip()
+	#print('processor_brand: ', processor_brand)
+
+	fields = None
+	if fields_index != -1:
+		fields = cpu_string[fields_index : ]
+	#print('fields: ', fields)
+
+	# Hz
+	scale, hz_brand = _get_hz_string_from_brand(processor_brand)
+
+	# Various fields
+	vendor_id, stepping, model, family = (None, None, None, None)
+	if fields:
+		try:
+			fields = fields.rsplit('(', 1)[1].split(')')[0].split(',')
+			fields = [f.strip().lower() for f in fields]
+			fields = [f.split(':') for f in fields]
+			fields = [{f[0].strip() : f[1].strip()} for f in fields]
+			#print('fields: ', fields)
+			for field in fields:
+				name = list(field.keys())[0]
+				value = list(field.values())[0]
+				#print('name:{0}, value:{1}'.format(name, value))
+				if name == 'origin':
+					vendor_id = value.strip('"')
+				elif name == 'stepping':
+					stepping = int(value.lstrip('0x'), 16)
+				elif name == 'model':
+					model = int(value.lstrip('0x'), 16)
+				elif name in ['fam', 'family']:
+					family = int(value.lstrip('0x'), 16)
+		except:
+			#raise
+			pass
+
+	return (processor_brand, hz_brand, scale, vendor_id, stepping, model, family)
+
+def _parse_dmesg_output(output):
+	try:
+		# Get all the dmesg lines that might contain a CPU string
+		lines = output.split(' CPU0:')[1:] + \
+				output.split(' CPU1:')[1:] + \
+				output.split(' CPU:')[1:] + \
+				output.split('\nCPU0:')[1:] + \
+				output.split('\nCPU1:')[1:] + \
+				output.split('\nCPU:')[1:]
+		lines = [l.split('\n')[0].strip() for l in lines]
+
+		# Convert the lines to CPU strings
+		cpu_strings = [_parse_cpu_string(l) for l in lines]
+
+		# Find the CPU string that has the most fields
+		best_string = None
+		highest_count = 0
+		for cpu_string in cpu_strings:
+			count = sum([n is not None for n in cpu_string])
+			if count > highest_count:
+				highest_count = count
+				best_string = cpu_string
+
+		# If no CPU string was found, return {}
+		if not best_string:
+			return {}
+
+		processor_brand, hz_actual, scale, vendor_id, stepping, model, family = best_string
+
+		# Origin
+		if '  Origin=' in output:
+			fields = output[output.find('  Origin=') : ].split('\n')[0]
+			fields = fields.strip().split()
+			fields = [n.strip().split('=') for n in fields]
+			fields = [{n[0].strip().lower() : n[1].strip()} for n in fields]
+			#print('fields: ', fields)
+			for field in fields:
+				name = list(field.keys())[0]
+				value = list(field.values())[0]
+				#print('name:{0}, value:{1}'.format(name, value))
+				if name == 'origin':
+					vendor_id = value.strip('"')
+				elif name == 'stepping':
+					stepping = int(value.lstrip('0x'), 16)
+				elif name == 'model':
+					model = int(value.lstrip('0x'), 16)
+				elif name in ['fam', 'family']:
+					family = int(value.lstrip('0x'), 16)
+		#print('FIELDS: ', (vendor_id, stepping, model, family))
+
+		# Features
+		flag_lines = []
+		for category in ['  Features=', '  Features2=', '  AMD Features=', '  AMD Features2=']:
+			if category in output:
+				flag_lines.append(output.split(category)[1].split('\n')[0])
+
+		flags = []
+		for line in flag_lines:
+			line = line.split('<')[1].split('>')[0].lower()
+			for flag in line.split(','):
+				flags.append(flag)
+		flags.sort()
+
+		# Convert from GHz/MHz string to Hz
+		scale, hz_advertised = _get_hz_string_from_brand(processor_brand)
+
+		info = {
+		'vendor_id' : vendor_id,
+		'brand' : processor_brand,
+
+		'stepping' : stepping,
+		'model' : model,
+		'family' : family,
+		'flags' : flags
+		}
+
+		if hz_advertised and hz_advertised != '0.0':
+			info['hz_advertised'] = to_friendly_hz(hz_advertised, scale)
+			info['hz_actual'] = to_friendly_hz(hz_actual, scale)
+
+		if hz_advertised and hz_advertised != '0.0':
+			info['hz_advertised_raw'] = to_raw_hz(hz_advertised, scale)
+			info['hz_actual_raw'] = to_raw_hz(hz_actual, scale)
+
+		return {k: v for k, v in info.items() if v}
+	except:
+		#raise
+		pass
+
+	return {}
+
 def parse_arch(raw_arch_string):
 	arch, bits = None, None
 	raw_arch_string = raw_arch_string.lower()
@@ -376,7 +557,7 @@
 		arch = 'X86_64'
 		bits = 64
 	# ARM
-	elif re.match('^armv8-a$', raw_arch_string):
+	elif re.match('^armv8-a|aarch64$', raw_arch_string):
 		arch = 'ARM_8'
 		bits = 64
 	elif re.match('^armv7$|^armv7[a-z]$|^armv7-[a-z]$|^armv6[a-z]$', raw_arch_string):
@@ -389,7 +570,7 @@
 	elif re.match('^ppc32$|^prep$|^pmac$|^powermac$', raw_arch_string):
 		arch = 'PPC_32'
 		bits = 32
-	elif re.match('^powerpc$|^ppc64$', raw_arch_string):
+	elif re.match('^powerpc$|^ppc64$|^ppc64le$', raw_arch_string):
 		arch = 'PPC_64'
 		bits = 64
 	# SPARC
@@ -410,6 +591,8 @@
 
 class CPUID(object):
 	def __init__(self):
+		self.prochandle = None
+
 		# Figure out if SE Linux is on and in enforcing mode
 		self.is_selinux_enforcing = False
 
@@ -429,9 +612,13 @@
 		if DataSource.is_windows:
 			# Allocate a memory segment the size of the byte code, and make it executable
 			size = len(byte_code)
+			# Alloc at least 1 page to ensure we own all pages that we want to change protection on
+			if size < 0x1000: size = 0x1000
 			MEM_COMMIT = ctypes.c_ulong(0x1000)
-			PAGE_EXECUTE_READWRITE = ctypes.c_ulong(0x40)
-			address = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_size_t(size), MEM_COMMIT, PAGE_EXECUTE_READWRITE)
+			PAGE_READWRITE = ctypes.c_ulong(0x4)
+			pfnVirtualAlloc = ctypes.windll.kernel32.VirtualAlloc
+			pfnVirtualAlloc.restype = ctypes.c_void_p
+			address = pfnVirtualAlloc(None, ctypes.c_size_t(size), MEM_COMMIT, PAGE_READWRITE)
 			if not address:
 				raise Exception("Failed to VirtualAlloc")
 
@@ -439,27 +626,48 @@
 			memmove = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t)(ctypes._memmove_addr)
 			if memmove(address, byte_code, size) < 0:
 				raise Exception("Failed to memmove")
+
+			# Enable execute permissions
+			PAGE_EXECUTE = ctypes.c_ulong(0x10)
+			old_protect = ctypes.c_ulong(0)
+			pfnVirtualProtect = ctypes.windll.kernel32.VirtualProtect
+			res = pfnVirtualProtect(ctypes.c_void_p(address), ctypes.c_size_t(size), PAGE_EXECUTE, ctypes.byref(old_protect))
+			if not res:
+				raise Exception("Failed VirtualProtect")
+
+			# Flush Instruction Cache
+			# First, get process Handle
+			if not self.prochandle:
+				pfnGetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess
+				pfnGetCurrentProcess.restype = ctypes.c_void_p
+				self.prochandle = ctypes.c_void_p(pfnGetCurrentProcess())
+			# Actually flush cache
+			res = ctypes.windll.kernel32.FlushInstructionCache(self.prochandle, ctypes.c_void_p(address), ctypes.c_size_t(size))
+			if not res:
+				raise Exception("Failed FlushInstructionCache")
 		else:
 			# Allocate a memory segment the size of the byte code
 			size = len(byte_code)
-			address = ctypes.pythonapi.valloc(size)
+			pfnvalloc = ctypes.pythonapi.valloc
+			pfnvalloc.restype = ctypes.c_void_p
+			address = pfnvalloc(ctypes.c_size_t(size))
 			if not address:
 				raise Exception("Failed to valloc")
 
 			# Mark the memory segment as writeable only
 			if not self.is_selinux_enforcing:
 				WRITE = 0x2
-				if ctypes.pythonapi.mprotect(address, size, WRITE) < 0:
+				if ctypes.pythonapi.mprotect(ctypes.c_void_p(address), size, WRITE) < 0:
 					raise Exception("Failed to mprotect")
 
 			# Copy the byte code into the memory segment
-			if ctypes.pythonapi.memmove(address, byte_code, size) < 0:
+			if ctypes.pythonapi.memmove(ctypes.c_void_p(address), byte_code, ctypes.c_size_t(size)) < 0:
 				raise Exception("Failed to memmove")
 
 			# Mark the memory segment as writeable and executable only
 			if not self.is_selinux_enforcing:
 				WRITE_EXECUTE = 0x2 | 0x4
-				if ctypes.pythonapi.mprotect(address, size, WRITE_EXECUTE) < 0:
+				if ctypes.pythonapi.mprotect(ctypes.c_void_p(address), size, WRITE_EXECUTE) < 0:
 					raise Exception("Failed to mprotect")
 
 		# Cast the memory segment into a function
@@ -469,55 +677,45 @@
 
 	def _run_asm(self, *byte_code):
 		# Convert the byte code into a function that returns an int
-		restype = None
-		if DataSource.bits == '64bit':
-			restype = ctypes.c_uint64
-		else:
-			restype = ctypes.c_uint32
+		restype = ctypes.c_uint32
 		argtypes = ()
 		func, address = self._asm_func(restype, argtypes, byte_code)
 
 		# Call the byte code like a function
 		retval = func()
 
+		byte_code = bytes.join(b'', byte_code)
 		size = ctypes.c_size_t(len(byte_code))
 
 		# Free the function memory segment
 		if DataSource.is_windows:
 			MEM_RELEASE = ctypes.c_ulong(0x8000)
-			ctypes.windll.kernel32.VirtualFree(address, size, MEM_RELEASE)
+			ctypes.windll.kernel32.VirtualFree(ctypes.c_void_p(address), ctypes.c_size_t(0), MEM_RELEASE)
 		else:
 			# Remove the executable tag on the memory
 			READ_WRITE = 0x1 | 0x2
-			if ctypes.pythonapi.mprotect(address, size, READ_WRITE) < 0:
+			if ctypes.pythonapi.mprotect(ctypes.c_void_p(address), size, READ_WRITE) < 0:
 				raise Exception("Failed to mprotect")
 
-			ctypes.pythonapi.free(address)
+			ctypes.pythonapi.free(ctypes.c_void_p(address))
 
 		return retval
 
 	# FIXME: We should not have to use different instructions to
 	# set eax to 0 or 1, on 32bit and 64bit machines.
 	def _zero_eax(self):
-		if DataSource.bits == '64bit':
-			return (
-				b"\x66\xB8\x00\x00" # mov eax,0x0"
-			)
-		else:
-			return (
-				b"\x31\xC0"         # xor ax,ax
-			)
+		return (
+			b"\x31\xC0"         # xor eax,eax
+		)
 
+	def _zero_ecx(self):
+		return (
+			b"\x31\xC9"         # xor ecx,ecx
+		)
 	def _one_eax(self):
-		if DataSource.bits == '64bit':
-			return (
-				b"\x66\xB8\x01\x00" # mov eax,0x1"
-			)
-		else:
-			return (
-				b"\x31\xC0"         # xor ax,ax
-				b"\x40"             # inc ax
-			)
+		return (
+			b"\xB8\x01\x00\x00\x00" # mov eax,0x1"
+		)
 
 	# http://en.wikipedia.org/wiki/CPUID#EAX.3D0:_Get_vendor_ID
 	def get_vendor_id(self):
@@ -580,7 +778,7 @@
 			'extended_family' : extended_family
 		}
 
-	# https://en.wikipedia.org/wiki/CPUID#EAX.3D80000000h:_Get_Highest_Extended_Function_Supported
+	# http://en.wikipedia.org/wiki/CPUID#EAX.3D80000000h:_Get_Highest_Extended_Function_Supported
 	def get_max_extension_support(self):
 		# Check for extension support
 		max_extension_support = self._run_asm(
@@ -681,18 +879,102 @@
 		# Get a list of only the flags that are true
 		flags = [k for k, v in flags.items() if v]
 
-		# Get the Extended CPU flags
-		extended_flags = {}
+		# http://en.wikipedia.org/wiki/CPUID#EAX.3D7.2C_ECX.3D0:_Extended_Features
+		if max_extension_support >= 7:
+			# EBX
+			ebx = self._run_asm(
+				self._zero_ecx(),
+				b"\xB8\x07\x00\x00\x00" # mov eax,7
+				b"\x0f\xa2"         # cpuid
+				b"\x89\xD8"         # mov ax,bx
+				b"\xC3"             # ret
+			)
 
-		# https://en.wikipedia.org/wiki/CPUID#EAX.3D7.2C_ECX.3D0:_Extended_Features
-		if max_extension_support == 7:
-			pass
-			# FIXME: Are we missing all these flags too?
-			# avx2 et cetera ...
+			# ECX
+			ecx = self._run_asm(
+				self._zero_ecx(),
+				b"\xB8\x07\x00\x00\x00" # mov eax,7
+				b"\x0f\xa2"         # cpuid
+				b"\x89\xC8"         # mov ax,cx
+				b"\xC3"             # ret
+			)
+
+			# Get the extended CPU flags
+			extended_flags = {
+				#'fsgsbase' : is_bit_set(ebx, 0),
+				#'IA32_TSC_ADJUST' : is_bit_set(ebx, 1),
+				'sgx' : is_bit_set(ebx, 2),
+				'bmi1' : is_bit_set(ebx, 3),
+				'hle' : is_bit_set(ebx, 4),
+				'avx2' : is_bit_set(ebx, 5),
+				#'reserved' : is_bit_set(ebx, 6),
+				'smep' : is_bit_set(ebx, 7),
+				'bmi2' : is_bit_set(ebx, 8),
+				'erms' : is_bit_set(ebx, 9),
+				'invpcid' : is_bit_set(ebx, 10),
+				'rtm' : is_bit_set(ebx, 11),
+				'pqm' : is_bit_set(ebx, 12),
+				#'FPU CS and FPU DS deprecated' : is_bit_set(ebx, 13),
+				'mpx' : is_bit_set(ebx, 14),
+				'pqe' : is_bit_set(ebx, 15),
+				'avx512f' : is_bit_set(ebx, 16),
+				'avx512dq' : is_bit_set(ebx, 17),
+				'rdseed' : is_bit_set(ebx, 18),
+				'adx' : is_bit_set(ebx, 19),
+				'smap' : is_bit_set(ebx, 20),
+				'avx512ifma' : is_bit_set(ebx, 21),
+				'pcommit' : is_bit_set(ebx, 22),
+				'clflushopt' : is_bit_set(ebx, 23),
+				'clwb' : is_bit_set(ebx, 24),
+				'intel_pt' : is_bit_set(ebx, 25),
+				'avx512pf' : is_bit_set(ebx, 26),
+				'avx512er' : is_bit_set(ebx, 27),
+				'avx512cd' : is_bit_set(ebx, 28),
+				'sha' : is_bit_set(ebx, 29),
+				'avx512bw' : is_bit_set(ebx, 30),
+				'avx512vl' : is_bit_set(ebx, 31),
+
+				'prefetchwt1' : is_bit_set(ecx, 0),
+				'avx512vbmi' : is_bit_set(ecx, 1),
+				'umip' : is_bit_set(ecx, 2),
+				'pku' : is_bit_set(ecx, 3),
+				'ospke' : is_bit_set(ecx, 4),
+				#'reserved' : is_bit_set(ecx, 5),
+				'avx512vbmi2' : is_bit_set(ecx, 6),
+				#'reserved' : is_bit_set(ecx, 7),
+				'gfni' : is_bit_set(ecx, 8),
+				'vaes' : is_bit_set(ecx, 9),
+				'vpclmulqdq' : is_bit_set(ecx, 10),
+				'avx512vnni' : is_bit_set(ecx, 11),
+				'avx512bitalg' : is_bit_set(ecx, 12),
+				#'reserved' : is_bit_set(ecx, 13),
+				'avx512vpopcntdq' : is_bit_set(ecx, 14),
+				#'reserved' : is_bit_set(ecx, 15),
+				#'reserved' : is_bit_set(ecx, 16),
+				#'mpx0' : is_bit_set(ecx, 17),
+				#'mpx1' : is_bit_set(ecx, 18),
+				#'mpx2' : is_bit_set(ecx, 19),
+				#'mpx3' : is_bit_set(ecx, 20),
+				#'mpx4' : is_bit_set(ecx, 21),
+				'rdpid' : is_bit_set(ecx, 22),
+				#'reserved' : is_bit_set(ecx, 23),
+				#'reserved' : is_bit_set(ecx, 24),
+				#'reserved' : is_bit_set(ecx, 25),
+				#'reserved' : is_bit_set(ecx, 26),
+				#'reserved' : is_bit_set(ecx, 27),
+				#'reserved' : is_bit_set(ecx, 28),
+				#'reserved' : is_bit_set(ecx, 29),
+				'sgx_lc' : is_bit_set(ecx, 30),
+				#'reserved' : is_bit_set(ecx, 31)
+			}
 
-		# https://en.wikipedia.org/wiki/CPUID#EAX.3D80000001h:_Extended_Processor_Info_and_Feature_Bits
+			# Get a list of only the flags that are true
+			extended_flags = [k for k, v in extended_flags.items() if v]
+			flags += extended_flags
+
+		# http://en.wikipedia.org/wiki/CPUID#EAX.3D80000001h:_Extended_Processor_Info_and_Feature_Bits
 		if max_extension_support >= 0x80000001:
-			# EBX # FIXME: This may need to be EDX instead
+			# EBX
 			ebx = self._run_asm(
 				b"\xB8\x01\x00\x00\x80" # mov ax,0x80000001
 				b"\x0f\xa2"         # cpuid
@@ -777,14 +1059,14 @@
 				#'reserved' : is_bit_set(ecx, 31)
 			}
 
-		# Get a list of only the flags that are true
-		extended_flags = [k for k, v in extended_flags.items() if v]
-		flags += extended_flags
+			# Get a list of only the flags that are true
+			extended_flags = [k for k, v in extended_flags.items() if v]
+			flags += extended_flags
 
 		flags.sort()
 		return flags
 
-	# https://en.wikipedia.org/wiki/CPUID#EAX.3D80000002h.2C80000003h.2C80000004h:_Processor_Brand_String
+	# http://en.wikipedia.org/wiki/CPUID#EAX.3D80000002h.2C80000003h.2C80000004h:_Processor_Brand_String
 	def get_processor_brand(self, max_extension_support):
 		processor_brand = ""
 
@@ -838,7 +1120,7 @@
 
 		return processor_brand
 
-	# https://en.wikipedia.org/wiki/CPUID#EAX.3D80000006h:_Extended_L2_Cache_Features
+	# http://en.wikipedia.org/wiki/CPUID#EAX.3D80000006h:_Extended_L2_Cache_Features
 	def get_cache(self, max_extension_support):
 		cache_info = {}
 
@@ -922,31 +1204,30 @@
 
 		return ticks
 
-def get_cpu_info_from_cpuid():
+def _actual_get_cpu_info_from_cpuid(queue):
 	'''
-	Returns the CPU info gathered by querying the X86 cpuid register in a new process.
-	Returns None of non X86 cpus.
-	Returns None if SELinux is in enforcing mode.
+	Warning! This function has the potential to crash the Python runtime.
+	Do not call it directly. Use the _get_cpu_info_from_cpuid function instead.
+	It will safely call this function in another process.
 	'''
 
-	returncode, output = run_and_get_stdout([sys.executable, "-c", "import cpuinfo; print(cpuinfo.actual_get_cpu_info_from_cpuid())"])
-	if returncode != 0:
-		return None
-	info = b64_to_obj(output)
-	return info
+	# Pipe all output to nothing
+	sys.stdout = open(os.devnull, 'w')
+	sys.stderr = open(os.devnull, 'w')
 
-def actual_get_cpu_info_from_cpuid():
 	# Get the CPU arch and bits
 	arch, bits = parse_arch(DataSource.raw_arch_string)
 
 	# Return none if this is not an X86 CPU
 	if not arch in ['X86_32', 'X86_64']:
-		return None
+		queue.put(obj_to_b64({}))
+		return
 
 	# Return none if SE Linux is in enforcing mode
 	cpuid = CPUID()
 	if cpuid.is_selinux_enforcing:
-		return None
+		queue.put(obj_to_b64({}))
+		return
 
 	# Get the cpu info from the CPUID register
 	max_extension_support = cpuid.get_max_extension_support()
@@ -961,23 +1242,17 @@
 
 	# Get the Hz and scale
 	scale, hz_advertised = _get_hz_string_from_brand(processor_brand)
-
 	info = {
 	'vendor_id' : cpuid.get_vendor_id(),
 	'hardware' : '',
 	'brand' : processor_brand,
 
 	'hz_advertised' : to_friendly_hz(hz_advertised, scale),
-	'hz_actual' : to_friendly_hz(hz_actual, 6),
+	'hz_actual' : to_friendly_hz(hz_actual, 0),
 	'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
-	'hz_actual_raw' : to_raw_hz(hz_actual, 6),
-
-	'arch' : arch,
-	'bits' : bits,
-	'count' : DataSource.cpu_count,
-	'raw_arch_string' : DataSource.raw_arch_string,
+	'hz_actual_raw' : to_raw_hz(hz_actual, 0),
 
-	'l2_cache_size' : cache_info['size_kb'],
+	'l2_cache_size' : to_friendly_bytes(cache_info['size_kb']),
 	'l2_cache_line_size' : cache_info['line_size_b'],
 	'l2_cache_associativity' : hex(cache_info['associativity']),
 
@@ -989,21 +1264,66 @@
 	'extended_family' : info['extended_family'],
 	'flags' : cpuid.get_flags(max_extension_support)
 	}
-	return obj_to_b64(info)
 
-def get_cpu_info_from_proc_cpuinfo():
+	info = {k: v for k, v in info.items() if v}
+	queue.put(obj_to_b64(info))
+
+def _get_cpu_info_from_cpuid():
+	'''
+	Returns the CPU info gathered by querying the X86 cpuid register in a new process.
+	Returns {} on non X86 cpus.
+	Returns {} if SELinux is in enforcing mode.
+	'''
+	from multiprocessing import Process, Queue
+
+	# Return {} if can't cpuid
+	if not DataSource.can_cpuid:
+		return {}
+
+	# Get the CPU arch and bits
+	arch, bits = parse_arch(DataSource.raw_arch_string)
+
+	# Return {} if this is not an X86 CPU
+	if not arch in ['X86_32', 'X86_64']:
+		return {}
+
+	try:
+		# Start running the function in a subprocess
+		queue = Queue()
+		p = Process(target=_actual_get_cpu_info_from_cpuid, args=(queue,))
+		p.start()
+
+		# Wait for the process to end, while it is still alive
+		while p.is_alive():
+			p.join(0)
+
+		# Return {} if it failed
+		if p.exitcode != 0:
+			return {}
+
+		# Return the result, only if there is something to read
+		if not queue.empty():
+			output = queue.get()
+			return b64_to_obj(output)
+	except:
+		pass
+
+	# Return {} if everything failed
+	return {}
+
+def _get_cpu_info_from_proc_cpuinfo():
 	'''
-	Returns the CPU info gathered from /proc/cpuinfo. Will return None if
-	/proc/cpuinfo is not found.
+	Returns the CPU info gathered from /proc/cpuinfo.
+	Returns {} if /proc/cpuinfo is not found.
 	'''
 	try:
-		# Just return None if there is no cpuinfo
+		# Just return {} if there is no cpuinfo
 		if not DataSource.has_proc_cpuinfo():
-			return None
+			return {}
 
 		returncode, output = DataSource.cat_proc_cpuinfo()
 		if returncode != 0:
-			return None
+			return {}
 
 		# Various fields
 		vendor_id = _get_field(False, output, None, '', 'vendor_id', 'vendor id', 'vendor')
@@ -1014,8 +1334,10 @@
 		family = _get_field(False, output, int, 0, 'cpu family')
 		hardware = _get_field(False, output, None, '', 'Hardware')
 		# Flags
-		flags = _get_field(False, output, None, None, 'flags', 'Features').split()
-		flags.sort()
+		flags = _get_field(False, output, None, None, 'flags', 'Features')
+		if flags:
+			flags = flags.split()
+			flags.sort()
 
 		# Convert from MHz string to Hz
 		hz_actual = _get_field(False, output, None, '', 'cpu MHz', 'cpu speed', 'clock')
@@ -1023,164 +1345,329 @@
 		hz_actual = to_hz_string(hz_actual)
 
 		# Convert from GHz/MHz string to Hz
-		scale, hz_advertised = _get_hz_string_from_brand(processor_brand)
-
-		# Try getting the Hz for a BeagleBone
-		if hz_advertised == '0.0':
-			scale, hz_advertised = _get_hz_string_from_beagle_bone()
-			hz_actual = hz_advertised
-
-		# Try getting the Hz for a lscpu
-		if hz_advertised == '0.0':
-			scale, hz_advertised = _get_hz_string_from_lscpu()
-			hz_actual = hz_advertised
-
-		# Get the CPU arch and bits
-		arch, bits = parse_arch(DataSource.raw_arch_string)
+		scale, hz_advertised = (0, None)
+		try:
+			scale, hz_advertised = _get_hz_string_from_brand(processor_brand)
+		except Exception:
+			pass
 
-		return {
-		'vendor_id' : vendor_id,
+		info = {
 		'hardware' : hardware,
 		'brand' : processor_brand,
 
-		'hz_advertised' : to_friendly_hz(hz_advertised, scale),
-		'hz_actual' : to_friendly_hz(hz_actual, 6),
-		'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
-		'hz_actual_raw' : to_raw_hz(hz_actual, 6),
-
-		'arch' : arch,
-		'bits' : bits,
-		'count' : DataSource.cpu_count,
-		'raw_arch_string' : DataSource.raw_arch_string,
-
-		'l2_cache_size' : cache_size,
-		'l2_cache_line_size' : 0,
-		'l2_cache_associativity' : 0,
-
+		'l3_cache_size' : to_friendly_bytes(cache_size),
+		'flags' : flags,
+		'vendor_id' : vendor_id,
 		'stepping' : stepping,
 		'model' : model,
 		'family' : family,
-		'processor_type' : 0,
-		'extended_model' : 0,
-		'extended_family' : 0,
-		'flags' : flags
 		}
+
+		# Make the Hz the same for actual and advertised if missing any
+		if not hz_advertised or hz_advertised == '0.0':
+			hz_advertised = hz_actual
+			scale = 6
+		elif not hz_actual or hz_actual == '0.0':
+			hz_actual = hz_advertised
+
+		# Add the Hz if there is one
+		if to_raw_hz(hz_advertised, scale) > (0, 0):
+			info['hz_advertised'] = to_friendly_hz(hz_advertised, scale)
+			info['hz_advertised_raw'] = to_raw_hz(hz_advertised, scale)
+		if to_raw_hz(hz_actual, scale) > (0, 0):
+			info['hz_actual'] = to_friendly_hz(hz_actual, 6)
+			info['hz_actual_raw'] = to_raw_hz(hz_actual, 6)
+
+		info = {k: v for k, v in info.items() if v}
+		return info
 	except:
 		#raise # NOTE: To have this throw on error, uncomment this line
-		return None
+		return {}
 
-def get_cpu_info_from_dmesg():
+def _get_cpu_info_from_cpufreq_info():
 	'''
-	Returns the CPU info gathered from dmesg. Will return None if
-	dmesg is not found or does not have the desired info.
+	Returns the CPU info gathered from cpufreq-info.
+	Returns {} if cpufreq-info is not found.
 	'''
 	try:
-		# Just return None if there is no dmesg
-		if not DataSource.has_dmesg():
-			return None
+		scale, hz_brand = 1, '0.0'
 
-		# If dmesg fails return None
-		returncode, output = DataSource.dmesg_a()
-		if output == None or returncode != 0:
-			return None
+		if not DataSource.has_cpufreq_info():
+			return {}
 
-		# Processor Brand
-		long_brand = output.split('CPU: ')[1].split('\n')[0]
-		processor_brand = long_brand.rsplit('(', 1)[0]
-		processor_brand = processor_brand.strip()
-
-		# Hz
-		scale = 0
-		hz_actual = long_brand.rsplit('(', 1)[1].split(' ')[0].lower()
-		if hz_actual.endswith('mhz'):
+		returncode, output = DataSource.cpufreq_info()
+		if returncode != 0:
+			return {}
+
+		hz_brand = output.split('current CPU frequency is')[1].split('\n')[0]
+		i = hz_brand.find('Hz')
+		assert(i != -1)
+		hz_brand = hz_brand[0 : i+2].strip().lower()
+
+		if hz_brand.endswith('mhz'):
 			scale = 6
-		elif hz_actual.endswith('ghz'):
+		elif hz_brand.endswith('ghz'):
 			scale = 9
-		hz_actual = hz_actual.split('-')[0]
-		hz_actual = to_hz_string(hz_actual)
+		hz_brand = hz_brand.rstrip('mhz').rstrip('ghz').strip()
+		hz_brand = to_hz_string(hz_brand)
 
-		# Various fields
-		fields = output.split('CPU: ')[1].split('\n')[1].split('\n')[0].strip().split('  ')
-		vendor_id = None
-		stepping = None
-		model = None
-		family = None
-		for field in fields:
-			name, value = field.split('=')
-			name = name.strip().lower()
-			value = value.strip()
-			if name == 'origin':
-				vendor_id = value.strip('"')
-			elif name == 'stepping':
-				stepping = int(value)
-			elif name == 'model':
-				model = int(value, 16)
-			elif name == 'family':
-				family = int(value, 16)
+		info = {
+			'hz_advertised' : to_friendly_hz(hz_brand, scale),
+			'hz_actual' : to_friendly_hz(hz_brand, scale),
+			'hz_advertised_raw' : to_raw_hz(hz_brand, scale),
+			'hz_actual_raw' : to_raw_hz(hz_brand, scale),
+		}
+
+		info = {k: v for k, v in info.items() if v}
+		return info
+	except:
+		#raise # NOTE: To have this throw on error, uncomment this line
+		return {}
+
+def _get_cpu_info_from_lscpu():
+	'''
+	Returns the CPU info gathered from lscpu.
+	Returns {} if lscpu is not found.
+	'''
+	try:
+		if not DataSource.has_lscpu():
+			return {}
+
+		returncode, output = DataSource.lscpu()
+		if returncode != 0:
+			return {}
+
+		info = {}
+
+		new_hz = _get_field(False, output, None, None, 'CPU max MHz', 'CPU MHz')
+		if new_hz:
+			new_hz = to_hz_string(new_hz)
+			scale = 6
+			info['hz_advertised'] = to_friendly_hz(new_hz, scale)
+			info['hz_actual'] = to_friendly_hz(new_hz, scale)
+			info['hz_advertised_raw'] = to_raw_hz(new_hz, scale)
+			info['hz_actual_raw'] = to_raw_hz(new_hz, scale)
+
+		vendor_id = _get_field(False, output, None, None, 'Vendor ID')
+		if vendor_id:
+			info['vendor_id'] = vendor_id
+
+		brand = _get_field(False, output, None, None, 'Model name')
+		if brand:
+			info['brand'] = brand
+
+		family = _get_field(False, output, None, None, 'CPU family')
+		if family and family.isdigit():
+			info['family'] = int(family)
+
+		stepping = _get_field(False, output, None, None, 'Stepping')
+		if stepping and stepping.isdigit():
+			info['stepping'] = int(stepping)
+
+		model = _get_field(False, output, None, None, 'Model')
+		if model and model.isdigit():
+			info['model'] = int(model)
+
+		l1_data_cache_size = _get_field(False, output, None, None, 'L1d cache')
+		if l1_data_cache_size:
+			info['l1_data_cache_size'] = to_friendly_bytes(l1_data_cache_size)
+
+		l1_instruction_cache_size = _get_field(False, output, None, None, 'L1i cache')
+		if l1_instruction_cache_size:
+			info['l1_instruction_cache_size'] = to_friendly_bytes(l1_instruction_cache_size)
+
+		l2_cache_size = _get_field(False, output, None, None, 'L2 cache')
+		if l2_cache_size:
+			info['l2_cache_size'] = to_friendly_bytes(l2_cache_size)
+
+		l3_cache_size = _get_field(False, output, None, None, 'L3 cache')
+		if l3_cache_size:
+			info['l3_cache_size'] = to_friendly_bytes(l3_cache_size)
 
 		# Flags
-		flag_lines = []
-		for category in ['  Features=', '  Features2=', '  AMD Features=', '  AMD Features2=']:
-			if category in output:
-				flag_lines.append(output.split(category)[1].split('\n')[0])
+		flags = _get_field(False, output, None, None, 'flags', 'Features')
+		if flags:
+			flags = flags.split()
+			flags.sort()
+			info['flags'] = flags
 
-		flags = []
-		for line in flag_lines:
-			line = line.split('<')[1].split('>')[0].lower()
-			for flag in line.split(','):
-				flags.append(flag)
-		flags.sort()
+		info = {k: v for k, v in info.items() if v}
+		return info
+	except:
+		#raise # NOTE: To have this throw on error, uncomment this line
+		return {}
 
-		# Convert from GHz/MHz string to Hz
-		scale, hz_advertised = _get_hz_string_from_brand(processor_brand)
+def _get_cpu_info_from_dmesg():
+	'''
+	Returns the CPU info gathered from dmesg.
+	Returns {} if dmesg is not found or does not have the desired info.
+	'''
+	# Just return {} if there is no dmesg
+	if not DataSource.has_dmesg():
+		return {}
 
-		# Get the CPU arch and bits
-		arch, bits = parse_arch(DataSource.raw_arch_string)
+	# If dmesg fails return {}
+	returncode, output = DataSource.dmesg_a()
+	if output == None or returncode != 0:
+		return {}
 
-		return {
-		'vendor_id' : vendor_id,
-		'hardware' : '',
-		'brand' : processor_brand,
+	return _parse_dmesg_output(output)
 
-		'hz_advertised' : to_friendly_hz(hz_advertised, scale),
-		'hz_actual' : to_friendly_hz(hz_actual, 6),
-		'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
-		'hz_actual_raw' : to_raw_hz(hz_actual, 6),
 
-		'arch' : arch,
-		'bits' : bits,
-		'count' : DataSource.cpu_count,
-		'raw_arch_string' : DataSource.raw_arch_string,
+# https://openpowerfoundation.org/wp-content/uploads/2016/05/LoPAPR_DRAFT_v11_24March2016_cmt1.pdf
+# page 767
+def _get_cpu_info_from_ibm_pa_features():
+	'''
+	Returns the CPU info gathered from lsprop /proc/device-tree/cpus/*/ibm,pa-features
+	Returns {} if lsprop is not found or ibm,pa-features does not have the desired info.
+	'''
+	try:
+		# Just return {} if there is no lsprop
+		if not DataSource.has_ibm_pa_features():
+			return {}
 
-		'l2_cache_size' : 0,
-		'l2_cache_line_size' : 0,
-		'l2_cache_associativity' : 0,
+		# If ibm,pa-features fails return {}
+		returncode, output = DataSource.ibm_pa_features()
+		if output == None or returncode != 0:
+			return {}
 
-		'stepping' : stepping,
-		'model' : model,
-		'family' : family,
-		'processor_type' : 0,
-		'extended_model' : 0,
-		'extended_family' : 0,
-		'flags' : flags
+		# Filter out invalid characters from output
+		value = output.split("ibm,pa-features")[1].lower()
+		value = [s for s in value if s in list('0123456789abcfed')]
+		value = ''.join(value)
+
+		# Get data converted to Uint32 chunks
+		left = int(value[0 : 8], 16)
+		right = int(value[8 : 16], 16)
+
+		# Get the CPU flags
+		flags = {
+			# Byte 0
+			'mmu' : is_bit_set(left, 0),
+			'fpu' : is_bit_set(left, 1),
+			'slb' : is_bit_set(left, 2),
+			'run' : is_bit_set(left, 3),
+			#'reserved' : is_bit_set(left, 4),
+			'dabr' : is_bit_set(left, 5),
+			'ne' : is_bit_set(left, 6),
+			'wtr' : is_bit_set(left, 7),
+
+			# Byte 1
+			'mcr' : is_bit_set(left, 8),
+			'dsisr' : is_bit_set(left, 9),
+			'lp' : is_bit_set(left, 10),
+			'ri' : is_bit_set(left, 11),
+			'dabrx' : is_bit_set(left, 12),
+			'sprg3' : is_bit_set(left, 13),
+			'rislb' : is_bit_set(left, 14),
+			'pp' : is_bit_set(left, 15),
+
+			# Byte 2
+			'vpm' : is_bit_set(left, 16),
+			'dss_2.05' : is_bit_set(left, 17),
+			#'reserved' : is_bit_set(left, 18),
+			'dar' : is_bit_set(left, 19),
+			#'reserved' : is_bit_set(left, 20),
+			'ppr' : is_bit_set(left, 21),
+			'dss_2.02' : is_bit_set(left, 22),
+			'dss_2.06' : is_bit_set(left, 23),
+
+			# Byte 3
+			'lsd_in_dscr' : is_bit_set(left, 24),
+			'ugr_in_dscr' : is_bit_set(left, 25),
+			#'reserved' : is_bit_set(left, 26),
+			#'reserved' : is_bit_set(left, 27),
+			#'reserved' : is_bit_set(left, 28),
+			#'reserved' : is_bit_set(left, 29),
+			#'reserved' : is_bit_set(left, 30),
+			#'reserved' : is_bit_set(left, 31),
+
+			# Byte 4
+			'sso_2.06' : is_bit_set(right, 0),
+			#'reserved' : is_bit_set(right, 1),
+			#'reserved' : is_bit_set(right, 2),
+			#'reserved' : is_bit_set(right, 3),
+			#'reserved' : is_bit_set(right, 4),
+			#'reserved' : is_bit_set(right, 5),
+			#'reserved' : is_bit_set(right, 6),
+			#'reserved' : is_bit_set(right, 7),
+
+			# Byte 5
+			'le' : is_bit_set(right, 8),
+			'cfar' : is_bit_set(right, 9),
+			'eb' : is_bit_set(right, 10),
+			'lsq_2.07' : is_bit_set(right, 11),
+			#'reserved' : is_bit_set(right, 12),
+			#'reserved' : is_bit_set(right, 13),
+			#'reserved' : is_bit_set(right, 14),
+			#'reserved' : is_bit_set(right, 15),
+
+			# Byte 6
+			'dss_2.07' : is_bit_set(right, 16),
+			#'reserved' : is_bit_set(right, 17),
+			#'reserved' : is_bit_set(right, 18),
+			#'reserved' : is_bit_set(right, 19),
+			#'reserved' : is_bit_set(right, 20),
+			#'reserved' : is_bit_set(right, 21),
+			#'reserved' : is_bit_set(right, 22),
+			#'reserved' : is_bit_set(right, 23),
+
+			# Byte 7
+			#'reserved' : is_bit_set(right, 24),
+			#'reserved' : is_bit_set(right, 25),
+			#'reserved' : is_bit_set(right, 26),
+			#'reserved' : is_bit_set(right, 27),
+			#'reserved' : is_bit_set(right, 28),
+			#'reserved' : is_bit_set(right, 29),
+			#'reserved' : is_bit_set(right, 30),
+			#'reserved' : is_bit_set(right, 31),
 		}
+
+		# Get a list of only the flags that are true
+		flags = [k for k, v in flags.items() if v]
+		flags.sort()
+
+		info = {
+			'flags' : flags
+		}
+		info = {k: v for k, v in info.items() if v}
+
+		return info
 	except:
-		return None
+		return {}
+
+
+def _get_cpu_info_from_cat_var_run_dmesg_boot():
+	'''
+	Returns the CPU info gathered from /var/run/dmesg.boot.
+	Returns {} if dmesg is not found or does not have the desired info.
+	'''
+	# Just return {} if there is no /var/run/dmesg.boot
+	if not DataSource.has_var_run_dmesg_boot():
+		return {}
+
+	# If dmesg.boot fails return {}
+	returncode, output = DataSource.cat_var_run_dmesg_boot()
+	if output == None or returncode != 0:
+		return {}
 
-def get_cpu_info_from_sysctl():
+	return _parse_dmesg_output(output)
+
+
+def _get_cpu_info_from_sysctl():
 	'''
-	Returns the CPU info gathered from sysctl. Will return None if
-	sysctl is not found.
+	Returns the CPU info gathered from sysctl.
+	Returns {} if sysctl is not found.
 	'''
 	try:
-		# Just return None if there is no sysctl
+		# Just return {} if there is no sysctl
 		if not DataSource.has_sysctl():
-			return None
+			return {}
 
-		# If sysctl fails return None
+		# If sysctl fails return {}
 		returncode, output = DataSource.sysctl_machdep_cpu_hw_cpufrequency()
 		if output == None or returncode != 0:
-			return None
+			return {}
 
 		# Various fields
 		vendor_id = _get_field(False, output, None, None, 'machdep.cpu.vendor')
@@ -1191,7 +1678,9 @@
 		family = _get_field(False, output, int, 0, 'machdep.cpu.family')
 
 		# Flags
-		flags = _get_field(False, output, None, None, 'machdep.cpu.features').lower().split()
+		flags = _get_field(False, output, None, '', 'machdep.cpu.features').lower().split()
+		flags.extend(_get_field(False, output, None, '', 'machdep.cpu.leaf7_features').lower().split())
+		flags.extend(_get_field(False, output, None, '', 'machdep.cpu.extfeatures').lower().split())
 		flags.sort()
 
 		# Convert from GHz/MHz string to Hz
@@ -1199,12 +1688,8 @@
 		hz_actual = _get_field(False, output, None, None, 'hw.cpufrequency')
 		hz_actual = to_hz_string(hz_actual)
 
-		# Get the CPU arch and bits
-		arch, bits = parse_arch(DataSource.raw_arch_string)
-
-		return {
+		info = {
 		'vendor_id' : vendor_id,
-		'hardware' : '',
 		'brand' : processor_brand,
 
 		'hz_advertised' : to_friendly_hz(hz_advertised, scale),
@@ -1212,40 +1697,43 @@
 		'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
 		'hz_actual_raw' : to_raw_hz(hz_actual, 0),
 
-		'arch' : arch,
-		'bits' : bits,
-		'count' : DataSource.cpu_count,
-		'raw_arch_string' : DataSource.raw_arch_string,
-
-		'l2_cache_size' : cache_size,
-		'l2_cache_line_size' : 0,
-		'l2_cache_associativity' : 0,
+		'l2_cache_size' : to_friendly_bytes(cache_size),
 
 		'stepping' : stepping,
 		'model' : model,
 		'family' : family,
-		'processor_type' : 0,
-		'extended_model' : 0,
-		'extended_family' : 0,
 		'flags' : flags
 		}
+
+		info = {k: v for k, v in info.items() if v}
+		return info
 	except:
-		return None
+		return {}
 
-def get_cpu_info_from_sysinfo():
+
+def _get_cpu_info_from_sysinfo():
 	'''
-	Returns the CPU info gathered from sysinfo. Will return None if
-	sysinfo is not found.
+	Returns the CPU info gathered from sysinfo.
+	Returns {} if sysinfo is not found.
+	'''
+	info = _get_cpu_info_from_sysinfo_v1()
+	info.update(_get_cpu_info_from_sysinfo_v2())
+	return info
+
+def _get_cpu_info_from_sysinfo_v1():
+	'''
+	Returns the CPU info gathered from sysinfo.
+	Returns {} if sysinfo is not found.
 	'''
 	try:
-		# Just return None if there is no sysinfo
+		# Just return {} if there is no sysinfo
 		if not DataSource.has_sysinfo():
-			return None
+			return {}
 
-		# If sysinfo fails return None
+		# If sysinfo fails return {}
 		returncode, output = DataSource.sysinfo_cpu()
 		if output == None or returncode != 0:
-			return None
+			return {}
 
 		# Various fields
 		vendor_id = '' #_get_field(False, output, None, None, 'CPU #0: ')
@@ -1267,12 +1755,8 @@
 		scale, hz_advertised = _get_hz_string_from_brand(processor_brand)
 		hz_actual = hz_advertised
 
-		# Get the CPU arch and bits
-		arch, bits = parse_arch(DataSource.raw_arch_string)
-
-		return {
+		info = {
 		'vendor_id' : vendor_id,
-		'hardware' : '',
 		'brand' : processor_brand,
 
 		'hz_advertised' : to_friendly_hz(hz_advertised, scale),
@@ -1280,36 +1764,173 @@
 		'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
 		'hz_actual_raw' : to_raw_hz(hz_actual, scale),
 
-		'arch' : arch,
-		'bits' : bits,
-		'count' : DataSource.cpu_count,
-		'raw_arch_string' : DataSource.raw_arch_string,
+		'l2_cache_size' : to_friendly_bytes(cache_size),
 
-		'l2_cache_size' : cache_size,
-		'l2_cache_line_size' : 0,
-		'l2_cache_associativity' : 0,
+		'stepping' : stepping,
+		'model' : model,
+		'family' : family,
+		'flags' : flags
+		}
+
+		info = {k: v for k, v in info.items() if v}
+		return info
+	except:
+		return {}
+
+def _get_cpu_info_from_sysinfo_v2():
+	'''
+	Returns the CPU info gathered from sysinfo.
+	Returns {} if sysinfo is not found.
+	'''
+	try:
+		# Just return {} if there is no sysinfo
+		if not DataSource.has_sysinfo():
+			return {}
+
+		# If sysinfo fails return {}
+		returncode, output = DataSource.sysinfo_cpu()
+		if output == None or returncode != 0:
+			return {}
+
+		# Various fields
+		vendor_id = '' #_get_field(False, output, None, None, 'CPU #0: ')
+		processor_brand = output.split('CPU #0: "')[1].split('"\n')[0]
+		cache_size = '' #_get_field(False, output, None, None, 'machdep.cpu.cache.size')
+		signature = output.split('Signature:')[1].split('\n')[0].strip()
+		#
+		stepping = int(signature.split('stepping ')[1].split(',')[0].strip())
+		model = int(signature.split('model ')[1].split(',')[0].strip())
+		family = int(signature.split('family ')[1].split(',')[0].strip())
+
+		# Flags
+		def get_subsection_flags(output):
+			retval = []
+			for line in output.split('\n')[1:]:
+				if not line.startswith('                '): break
+				for entry in line.strip().lower().split(' '):
+					retval.append(entry)
+			return retval
+
+		flags = get_subsection_flags(output.split('Features: ')[1]) + \
+				get_subsection_flags(output.split('Extended Features (0x00000001): ')[1]) + \
+				get_subsection_flags(output.split('Extended Features (0x80000001): ')[1])
+		flags.sort()
+
+		# Convert from GHz/MHz string to Hz
+		scale, hz_advertised = _get_hz_string_from_brand(processor_brand)
+		hz_actual = hz_advertised
+
+		info = {
+		'vendor_id' : vendor_id,
+		'brand' : processor_brand,
+
+		'hz_advertised' : to_friendly_hz(hz_advertised, scale),
+		'hz_actual' : to_friendly_hz(hz_actual, scale),
+		'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
+		'hz_actual_raw' : to_raw_hz(hz_actual, scale),
+
+		'l2_cache_size' : to_friendly_bytes(cache_size),
 
 		'stepping' : stepping,
 		'model' : model,
 		'family' : family,
-		'processor_type' : 0,
-		'extended_model' : 0,
-		'extended_family' : 0,
 		'flags' : flags
 		}
+
+		info = {k: v for k, v in info.items() if v}
+		return info
+	except:
+		return {}
+
+def _get_cpu_info_from_wmic():
+	'''
+	Returns the CPU info gathered from WMI.
+	Returns {} if not on Windows, or wmic is not installed.
+	'''
+
+	try:
+		# Just return {} if not Windows or there is no wmic
+		if not DataSource.is_windows or not DataSource.has_wmic():
+			return {}
+
+		returncode, output = DataSource.wmic_cpu()
+		if output == None or returncode != 0:
+			return {}
+
+		# Break the list into key values pairs
+		value = output.split("\n")
+		value = [s.rstrip().split('=') for s in value if '=' in s]
+		value = {k: v for k, v in value if v}
+
+		# Get the advertised MHz
+		processor_brand = value.get('Name')
+		scale_advertised, hz_advertised = _get_hz_string_from_brand(processor_brand)
+
+		# Get the actual MHz
+		hz_actual = value.get('CurrentClockSpeed')
+		scale_actual = 6
+		if hz_actual:
+			hz_actual = to_hz_string(hz_actual)
+
+		# Get cache sizes
+		l2_cache_size = value.get('L2CacheSize')
+		if l2_cache_size:
+			l2_cache_size = l2_cache_size + ' KB'
+
+		l3_cache_size = value.get('L3CacheSize')
+		if l3_cache_size:
+			l3_cache_size = l3_cache_size + ' KB'
+
+		# Get family, model, and stepping
+		family, model, stepping = '', '', ''
+		description = value.get('Description') or value.get('Caption')
+		entries = description.split(' ')
+
+		if 'Family' in entries and entries.index('Family') < len(entries)-1:
+			i = entries.index('Family')
+			family = int(entries[i + 1])
+
+		if 'Model' in entries and entries.index('Model') < len(entries)-1:
+			i = entries.index('Model')
+			model = int(entries[i + 1])
+
+		if 'Stepping' in entries and entries.index('Stepping') < len(entries)-1:
+			i = entries.index('Stepping')
+			stepping = int(entries[i + 1])
+
+		info = {
+			'vendor_id' : value.get('Manufacturer'),
+			'brand' : processor_brand,
+
+			'hz_advertised' : to_friendly_hz(hz_advertised, scale_advertised),
+			'hz_actual' : to_friendly_hz(hz_actual, scale_actual),
+			'hz_advertised_raw' : to_raw_hz(hz_advertised, scale_advertised),
+			'hz_actual_raw' : to_raw_hz(hz_actual, scale_actual),
+
+			'l2_cache_size' : l2_cache_size,
+			'l3_cache_size' : l3_cache_size,
+
+			'stepping' : stepping,
+			'model' : model,
+			'family' : family,
+		}
+
+		info = {k: v for k, v in info.items() if v}
+		return info
 	except:
-		return None
+		#raise # NOTE: To have this throw on error, uncomment this line
+		return {}
 
-def get_cpu_info_from_registry():
+def _get_cpu_info_from_registry():
 	'''
 	FIXME: Is missing many of the newer CPU flags like sse3
-	Returns the CPU info gathered from the Windows Registry. Will return None if
-	not on Windows.
+	Returns the CPU info gathered from the Windows Registry.
+	Returns {} if not on Windows.
 	'''
 	try:
-		# Just return None if not on Windows
+		# Just return {} if not on Windows
 		if not DataSource.is_windows:
-			return None
+			return {}
 
 		# Get the CPU name
 		processor_brand = DataSource.winreg_processor_brand()
@@ -1378,9 +1999,8 @@
 		flags = [k for k, v in flags.items() if v]
 		flags.sort()
 
-		return {
+		info = {
 		'vendor_id' : vendor_id,
-		'hardware' : '',
 		'brand' : processor_brand,
 
 		'hz_advertised' : to_friendly_hz(hz_advertised, scale),
@@ -1388,50 +2008,37 @@
 		'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
 		'hz_actual_raw' : to_raw_hz(hz_actual, 6),
 
-		'arch' : arch,
-		'bits' : bits,
-		'count' : DataSource.cpu_count,
-		'raw_arch_string' : raw_arch_string,
-
-		'l2_cache_size' : 0,
-		'l2_cache_line_size' : 0,
-		'l2_cache_associativity' : 0,
-
-		'stepping' : 0,
-		'model' : 0,
-		'family' : 0,
-		'processor_type' : 0,
-		'extended_model' : 0,
-		'extended_family' : 0,
 		'flags' : flags
 		}
+
+		info = {k: v for k, v in info.items() if v}
+		return info
 	except:
-		return None
+		return {}
 
-def get_cpu_info_from_kstat():
+def _get_cpu_info_from_kstat():
 	'''
-	Returns the CPU info gathered from isainfo and kstat. Will
-	return None if isainfo or kstat are not found.
+	Returns the CPU info gathered from isainfo and kstat.
+	Returns {} if isainfo or kstat are not found.
 	'''
 	try:
-		# Just return None if there is no isainfo or kstat
+		# Just return {} if there is no isainfo or kstat
 		if not DataSource.has_isainfo() or not DataSource.has_kstat():
-			return None
+			return {}
 
-		# If isainfo fails return None
+		# If isainfo fails return {}
 		returncode, flag_output = DataSource.isainfo_vb()
 		if flag_output == None or returncode != 0:
-			return None
+			return {}
 
-		# If kstat fails return None
+		# If kstat fails return {}
 		returncode, kstat = DataSource.kstat_m_cpu_info()
 		if kstat == None or returncode != 0:
-			return None
+			return {}
 
 		# Various fields
 		vendor_id = kstat.split('\tvendor_id ')[1].split('\n')[0].strip()
 		processor_brand = kstat.split('\tbrand ')[1].split('\n')[0].strip()
-		cache_size = 0
 		stepping = int(kstat.split('\tstepping ')[1].split('\n')[0].strip())
 		model = int(kstat.split('\tmodel ')[1].split('\n')[0].strip())
 		family = int(kstat.split('\tfamily ')[1].split('\n')[0].strip())
@@ -1449,12 +2056,8 @@
 		hz_actual = kstat.split('\tcurrent_clock_Hz ')[1].split('\n')[0].strip()
 		hz_actual = to_hz_string(hz_actual)
 
-		# Get the CPU arch and bits
-		arch, bits = parse_arch(DataSource.raw_arch_string)
-
-		return {
+		info = {
 		'vendor_id' : vendor_id,
-		'hardware' : '',
 		'brand' : processor_brand,
 
 		'hz_advertised' : to_friendly_hz(hz_advertised, scale),
@@ -1462,64 +2065,100 @@
 		'hz_advertised_raw' : to_raw_hz(hz_advertised, scale),
 		'hz_actual_raw' : to_raw_hz(hz_actual, 0),
 
-		'arch' : arch,
-		'bits' : bits,
-		'count' : DataSource.cpu_count,
-		'raw_arch_string' : DataSource.raw_arch_string,
-
-		'l2_cache_size' : cache_size,
-		'l2_cache_line_size' : 0,
-		'l2_cache_associativity' : 0,
-
 		'stepping' : stepping,
 		'model' : model,
 		'family' : family,
-		'processor_type' : 0,
-		'extended_model' : 0,
-		'extended_family' : 0,
 		'flags' : flags
 		}
+
+		info = {k: v for k, v in info.items() if v}
+		return info
 	except:
-		return None
+		return {}
+
+def CopyNewFields(info, new_info):
+	keys = [
+		'vendor_id', 'hardware', 'brand', 'hz_advertised', 'hz_actual',
+		'hz_advertised_raw', 'hz_actual_raw', 'arch', 'bits', 'count',
+		'raw_arch_string', 'l2_cache_size', 'l2_cache_line_size',
+		'l2_cache_associativity', 'stepping', 'model', 'family',
+		'processor_type', 'extended_model', 'extended_family', 'flags',
+		'l3_cache_size', 'l1_data_cache_size', 'l1_instruction_cache_size'
+	]
+
+	for key in keys:
+		if new_info.get(key, None) and not info.get(key, None):
+			info[key] = new_info[key]
+		elif key == 'flags' and new_info.get('flags'):
+			for f in new_info['flags']:
+				if f not in info['flags']: info['flags'].append(f)
+			info['flags'].sort()
 
 def get_cpu_info():
-	info = None
+	'''
+	Returns the CPU info by using the best sources of information for your OS.
+	Returns {} if nothing is found.
+	'''
+
+	# Get the CPU arch and bits
+	arch, bits = parse_arch(DataSource.raw_arch_string)
+
+	friendly_maxsize = { 2**31-1: '32 bit', 2**63-1: '64 bit' }.get(sys.maxsize) or 'unknown bits'
+	friendly_version = "{0}.{1}.{2}.{3}.{4}".format(*sys.version_info)
+	PYTHON_VERSION = "{0} ({1})".format(friendly_version, friendly_maxsize)
+
+	info = {
+		'python_version' : PYTHON_VERSION,
+		'cpuinfo_version' : CPUINFO_VERSION,
+		'arch' : arch,
+		'bits' : bits,
+		'count' : DataSource.cpu_count,
+		'raw_arch_string' : DataSource.raw_arch_string,
+	}
+
+	# Try the Windows wmic
+	CopyNewFields(info, _get_cpu_info_from_wmic())
 
 	# Try the Windows registry
-	if not info:
-		info = get_cpu_info_from_registry()
+	CopyNewFields(info, _get_cpu_info_from_registry())
 
 	# Try /proc/cpuinfo
-	if not info:
-		info = get_cpu_info_from_proc_cpuinfo()
+	CopyNewFields(info, _get_cpu_info_from_proc_cpuinfo())
+
+	# Try cpufreq-info
+	CopyNewFields(info, _get_cpu_info_from_cpufreq_info())
+
+	# Try LSCPU
+	CopyNewFields(info, _get_cpu_info_from_lscpu())
 
 	# Try sysctl
-	if not info:
-		info = get_cpu_info_from_sysctl()
+	CopyNewFields(info, _get_cpu_info_from_sysctl())
 
 	# Try kstat
-	if not info:
-		info = get_cpu_info_from_kstat()
+	CopyNewFields(info, _get_cpu_info_from_kstat())
 
 	# Try dmesg
-	if not info:
-		info = get_cpu_info_from_dmesg()
+	CopyNewFields(info, _get_cpu_info_from_dmesg())
+
+	# Try /var/run/dmesg.boot
+	CopyNewFields(info, _get_cpu_info_from_cat_var_run_dmesg_boot())
+
+	# Try lsprop ibm,pa-features
+	CopyNewFields(info, _get_cpu_info_from_ibm_pa_features())
 
 	# Try sysinfo
-	if not info:
-		info = get_cpu_info_from_sysinfo()
+	CopyNewFields(info, _get_cpu_info_from_sysinfo())
 
 	# Try querying the CPU cpuid register
-	if not info:
-		info = get_cpu_info_from_cpuid()
+	CopyNewFields(info, _get_cpu_info_from_cpuid())
 
 	return info
 
 # Make sure we are running on a supported system
 def _check_arch():
 	arch, bits = parse_arch(DataSource.raw_arch_string)
-	if not arch in ['X86_32', 'X86_64', 'ARM_7', 'ARM_8']:
-		raise Exception("py-cpuinfo currently only works on X86 and some ARM CPUs.")
+	if not arch in ['X86_32', 'X86_64', 'ARM_7', 'ARM_8', 'PPC_64']:
+		raise Exception("py-cpuinfo currently only works on X86 and some PPC and ARM CPUs.")
 
 def main():
 	try:
@@ -1530,6 +2169,8 @@
 
 	info = get_cpu_info()
 	if info:
+		print('Python Version: {0}'.format(info.get('python_version', '')))
+		print('Cpuinfo Version: {0}'.format(info.get('cpuinfo_version', '')))
 		print('Vendor ID: {0}'.format(info.get('vendor_id', '')))
 		print('Hardware Raw: {0}'.format(info.get('hardware', '')))
 		print('Brand: {0}'.format(info.get('brand', '')))
@@ -1543,10 +2184,12 @@
 
 		print('Raw Arch String: {0}'.format(info.get('raw_arch_string', '')))
 
+		print('L1 Data Cache Size: {0}'.format(info.get('l1_data_cache_size', '')))
+		print('L1 Instruction Cache Size: {0}'.format(info.get('l1_instruction_cache_size', '')))
 		print('L2 Cache Size: {0}'.format(info.get('l2_cache_size', '')))
 		print('L2 Cache Line Size: {0}'.format(info.get('l2_cache_line_size', '')))
 		print('L2 Cache Associativity: {0}'.format(info.get('l2_cache_associativity', '')))
-
+		print('L3 Cache Size: {0}'.format(info.get('l3_cache_size', '')))
 		print('Stepping: {0}'.format(info.get('stepping', '')))
 		print('Model: {0}'.format(info.get('model', '')))
 		print('Family: {0}'.format(info.get('family', '')))
@@ -1560,6 +2203,8 @@
 
 
 if __name__ == '__main__':
+	from multiprocessing import freeze_support
+	freeze_support()
 	main()
 else:
 	_check_arch()
